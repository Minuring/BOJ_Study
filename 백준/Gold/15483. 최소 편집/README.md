# [Gold III] 최소 편집 - 15483 

[문제 링크](https://www.acmicpc.net/problem/15483) 

### 성능 요약

메모리: 65948 KB, 시간: 896 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2023년 11월 25일 16:15:45

### 문제 설명

<p>두 문자열 A와 B가 주어졌을 때, A에 연산을 최소 횟수로 수행해 B로 만드는 문제를 "최소 편집" 문제라고 한다.</p>

<p>A에 적용할 수 있는 연산은 총 3가지가 있으며 아래와 같다.</p>

<ol>
	<li>삽입: A의 한 위치에 문자 하나를 삽입한다.</li>
	<li>삭제: A의 문자 하나를 삭제한다.</li>
	<li>교체: A의 문자 하나를 다른 문자로 교체한다.</li>
</ol>

<p>두 문자열이 주어졌을 때, 최소 편집 횟수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 소문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.</p>

### 출력 

 <p>첫째 줄에 최소 편집 횟수를 출력한다.</p>

### 문제 풀이

<pre>문자열 A에서 문자열 B로 변경되기 위한 최소 편집(삽입,삭제,대체) 횟수
2차원 배열 (행 : 0~A의길이, 열 : 0~B의길이) 을 만들고 이를 채워나간다.
dp[i][j] 는 A의 1~i번째까지를 B의 1~j번째까지의 문자로 편집하는 최소편집거리이다.
ex) [A] MICROSOFT -> [B] NCSOFT
dp[4][3] = "MICR" -> "NCS" 로 바꾸는 최소 편집거리

0번째 행 dp[0][j] 는 "" -> ""~"NCSOFT" 이므로 dp[0][j] = j 즉 0,1,,,len(B)이다.
0번째 열 dp[i][0] 는 ""~"MICROSOFT" -> "" 이므로 dp[i][0] = i 즉 0,1,,,len(A)이다.

<strong>dp[i][j] =</strong> 
    
    if Ai == Bj 이면 즉 (A의 i번째문자 == B의 j번째문자) 이면 A의 i번째문자를 B의 j번째문자로 <b>변경할 필요가 없다.</b>
        dp[i-1][j-1]
    
    else (Ai != Bj 이면)
        (Ai ->B_j-1까지 편집 후 Bj삽입) : dp[i][j-1] + 1
        (A_i-1 ->B_j-1까지 편집 후 Ai대체) : dp[i-1][j-1] + 1
        (A_i-1 ->B_j까지 편집 후 Ai삭제) : dp[i-1][j] + 1
        위 3가지 경우 중 최소값

<b>이다.</b>

2차원배열 크기만큼 비교연산을 수행하므로 시간복잡도는 A의길이*B의길이이다. O(NM)
